---
title: 객체지향 분석의 방법론
date: 2025-01-29 04:59:00 +09:00
categories: [정보처리기사, 필기]
tags: [정보처리기사, 필기, 이론, 객체지향 분석의 방법론]
---
### 들어가기에 앞서
- [객체지향 방법론](https://parkyaeseong.github.io/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%B0%A9%EB%B2%95%EB%A1%A0/)

## 객체지향 분석의 방법론

**객체지향 분석(OOA; Object Oriented Analysis)**  
사용자의 요구사항을 분석하여 **요구된 문제와 관련된 모든 클래스(객체), 속성, 연산, 관계 등을 정의하는 모델링 작업**.  
객체는 클래스로부터 인스턴스화되며, 클래스 식별이 주요 목적.

---

## 1. 주요 객체지향 분석 방법론

### Rumbaugh(럼바우) 방법  
 - 모든 소프트웨어 구성 요소를 **그래픽** 표기법을 이용한 객체 모델링 기법(Object Modeling Technique)  
 - 분석 단계: **객체 모델링 → 동적 모델링 → 기능 모델링**

### Booch(부치) 방법  
 - **미시적(Micro)/거시적(Macro)** 개발 프로세스 통합  
 - 클래스/객체 식별 후 속성·연산 정의

### Jacobson 방법  
 - **Use Case** 강조 분석 기법

### Coad와 Yourdon 방법  
 - **E-R 다이어그램** 활용, 객체 행위 모델링  
 - 단계: 객체 식별 → 구조 식별 → 주제 정의 → 속성과 인스턴스 연결 정의 → 연산/메시지 연결 정의...

### Wirfs-Brock 방법  
 - 분석-설계 구분 없이, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

---

## 2. 럼바우(Rumbaugh) 분석 기법

| 구분             | 설명                                                                 |
|------------------|----------------------------------------------------------------------|
| **객체 모델링(Object Modeling)**  | **객체 다이어그램**으로 시스템에서 요구되는 객체를 찾아내어  <br> 속성과 연산 식별 및 객체 간 관계 규정 (정보 모델링)                 |
| **동적 모델링(Dynamic Modeling)**  | **상태 다이어그램(상태도)**으로 시간 흐름에 따른 객체 간  <br> 제어 흐름, 상호 작용, 동작 순서 등 동적인 행위를 표현                 |
| **기능 모델링(Function Modeling)**  | **자료 흐름도(DFD)**로 다수의 프로세스 간 자료 흐름를 중심으로 <br> 처리 과정을 표현                       |

---

## 3. 객체지향 설계 원칙: SOLID 원칙

> 시스템의 변경이나 확장성에 유연한 시스템을 설계하기 위해 지켜야할 다섯가지 원칙

| 원칙                      | 설명                                                                 |
|---------------------------|----------------------------------------------------------------------|
| **SRP(Single Responsibility)** <br> **단일 책임 원칙**  | 객체는 단 하나의 책임만 가짐 → **응집도 ↑, 결합도 ↓**              |
| **OCP(Open-Closed)** <br> **개방-폐쇄 원칙**  | - **"확장에는 열려있고, 변경에는 닫혀있음"**  <br> - 기존의 코드 변경 없이 기능을 추가할 수 있도록 설계   <br>  - 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화  <br>   - 디자인 패턴들의 기본 원칙이 되는 원칙으로 변하는 부분과 <br> 변하지 않는 부분을 분리           |
| **LSP (Liskov Substitution)** <br> **리스코프 치환**   | **자식(Sub)은 부모(Super)로 치환 될 수 있다**   <br>   - 하위 클래스는 상위 클래스에서 가능한 행위 수행 가능   <br>   - 하위 클래스는 상위 클래스를 무시하거나 재정의하지 않고 확장만 수행         |
| **ISP (Interface Segregration)** <br> **인터페이스 분리** | 사용하지 않는 인터페이스와의 의존성 배제  <br> → 단일 책임 인터페이스     |
| **DIP (Dependency Inversion)** <br> **의존 역전**       | **상위 모듈이 하위 모듈에 의존해서 안되며(완벽하게 분리), <br> 모든 것은 추상에 의존해야 한다**  <br> → 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존관계를 <br> 맺어야 함                |

**+ 디미터의 법칙(Demeter's Law, LoD)**   
: '친한 친구들 하고만 이야기 하여라' = 동일한 객체 내의 메소드 및 속성을 주로 사용할 것   
(SRP와 마찬가지로 **결합도 ↓, 응집도 ↑**)

---
